{
  "id":"kaa",
  "name":"KickAssAnime",
  "version":"1.0.0",
  "manifestURI":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/kaa/manifest.json",
  "language":"typescript",
  "type":"onlinestream-provider",
  "description":"KickAssAnime is an online stream provider for both sub and dub with soft subs.",
  "author":"Thekingcrusher",
  "icon":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/kaa/logo.ico",
  "lang":"en",
  "payload":"/// \u003creference path=\"./online-streaming-provider.d.ts\" /\u003e\n\nclass Provider {\n  private base = \"https://kaa.to\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"VidStreaming\", \"CatStream\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise\u003cSearchResult[]\u003e {\n    const res = await fetch(`${this.base}/api/fsearch`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query: query.query,\n        page: 1,\n      }),\n    });\n  \n    const data = await res.json();\n  \n    if (!data.result || data.result.length === 0) {\n      throw new Error(\"ERROR: no anime found\");\n    }\n  \n    return data.result.map((item) =\u003e ({\n      id: `${item.slug}/${query.dub ? \"dub\" : \"sub\"}`,\n      title: item.title_en || item.title,\n      url: `https://kaa.to${item.watch_uri}`,\n      subOrDub: query.dub ? \"dub\" : \"sub\",\n    }));\n  }\n\n  async findEpisodes(id: string): Promise\u003cEpisode[]\u003e {\n    const [slug, type] = id.split(\"/\");\n\n    // Fetch available languages for the show\n    const langRes = await fetch(`${this.base}/api/show/${slug}/language`);\n    const langJson = await langRes.json();\n    const langData: string[] = langJson.result;\n  \n    // Determine language\n    let lang: string;\n    if (type === \"dub\") {\n      // Figure out what sub would have picked\n      const subLang =\n        langData.includes(\"zh-CN\")\n          ? \"zh-CN\"\n          : langData.includes(\"ja-JP\")\n            ? \"ja-JP\"\n            : langData[0];\n  \n      if (subLang === \"ja-JP\") {\n        // If sub is ja-JP, then prefer en-US for dub if possible\n        lang = langData.includes(\"en-US\") ? \"en-US\" : langData[0];\n      } else {\n        // Otherwise, prefer ja-JP for dub\n        lang = langData.includes(\"ja-JP\") ? \"ja-JP\" : langData[0];\n      }\n    } else {\n      // Sub logic: prefer zh-CN \u003e ja-JP \u003e first\n      lang =\n        langData.includes(\"zh-CN\")\n          ? \"zh-CN\"\n          : langData.includes(\"ja-JP\")\n            ? \"ja-JP\"\n            : langData[0];\n    }\n  \n    const baseUrl = `${this.base}/api/show/${slug}/episodes?ep=1\u0026lang=${lang}`;\n  \n    // Fetch first page\n    const firstRes = await fetch(`${baseUrl}\u0026page=1`);\n    const firstData = await firstRes.json();\n  \n    // Determine all pages to fetch\n    const pages = firstData.pages?.map((p: any) =\u003e p.number) || [1];\n  \n    // Fetch all other pages in parallel\n    const otherPagePromises = pages\n      .filter((p) =\u003e p !== 1)\n      .map((page) =\u003e fetch(`${baseUrl}\u0026page=${page}`).then((r) =\u003e r.json()));\n  \n    const otherPageData = await Promise.all(otherPagePromises);\n  \n    // Combine all results into one array\n    const allResults = [firstData, ...otherPageData]\n      .flatMap((pageData) =\u003e pageData.result)\n      .filter((ep: any) =\u003e Number.isInteger(ep.episode_number)); // Skip non-integer episodes\n  \n    return allResults.map((ep: any) =\u003e ({\n      id: ep.slug,\n      title: ep.title || `Episode ${ep.episode_string}`,\n      number: ep.episode_number,\n      url: `${this.base}/api/show/${slug}/episode/ep-${ep.episode_string}-${ep.slug}`,\n    }));\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n    const res = await fetch(episode.url);\n    const data = await res.json();\n  \n    const server = data.servers.find((s: any) =\u003e\n      s.name.toLowerCase().trim() === _server.toLowerCase().trim()\n    );\n    if (!server) {\n      console.warn(\"Available servers:\", data.servers.map((s: any) =\u003e s.name));\n      throw new Error(\"ERROR: server not found\");\n    }\n  \n    let videoUrl = server.src;\n    let subtitles: Subtitle[] = [];\n  \n    if (_server.toLowerCase() === \"vidstreaming\") {\n      const source = await extractVidstreamingStreams(server.src);\n      videoUrl = source.m3u8;\n  \n      subtitles = source.subtitles.map(sub =\u003e ({\n        id: sub.id,\n        url: sub.file.startsWith(\"//\") ? `https:${sub.file}` : sub.file,\n        language: sub.label,\n        isDefault: sub.label.toLowerCase().includes(\"english\")\n      }));\n    } else if (_server.toLowerCase() === \"catstream\") {\n      const playerRes = await fetch(videoUrl);\n      const html = await playerRes.text();\n  \n      const astroMatch = html.match(/\u003castro-island[^\u003e]+props=\"([^\"]+)\"[^\u003e]*\u003e/);\n      if (!astroMatch) throw new Error(\"Astro-island props not found in CatStream player\");\n  \n      const propsStr = astroMatch[1].replace(/\u0026quot;/g, '\"');\n      const props = JSON.parse(propsStr);\n  \n      if (props.manifest \u0026\u0026 props.manifest[1]) {\n        let manifestUrl = props.manifest[1];\n        if (manifestUrl.startsWith(\"//\")) {\n          manifestUrl = \"https:\" + manifestUrl;\n        } else if (!manifestUrl.startsWith(\"http\")) {\n          manifestUrl = \"https://\" + manifestUrl;\n        }\n        videoUrl = manifestUrl;\n      } else {\n        throw new Error(\"Manifest URL not found\");\n      }\n  \n      subtitles = (props.subtitles \u0026\u0026 props.subtitles[1]) ? props.subtitles[1].map((sub: any) =\u003e {\n        const urlRaw = sub[1].src[1];\n        const urlFixed = urlRaw.replace(\"https:///\", \"https://\");\n        const languageCode = sub[1].language[1];\n        const languageName = sub[1].name[1];\n  \n        return {\n          id: languageCode,\n          url: urlFixed,\n          language: languageName,\n          isDefault: languageCode === \"en\",\n        };\n      }) : [];\n    }\n  \n    return {\n      server: _server,\n      headers: {\n        \"Origin\": \"https://krussdomi.com\",\n        \"Referer\": server.src,\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n      },\n      videoSources: [\n        {\n          url: videoUrl,\n          quality: \"auto\",\n          type: \"m3u8\",\n          subtitles,\n        },\n      ],\n    };\n  }\n}\n\nasync function extractVidstreamingStreams(playerUrl) {\n  const key = CryptoJS.enc.Hex.parse(\"e13d38099bf562e8b9851a652d2043d3\");\n\n  // 1. Fetch player HTML\n  const html = await fetch(playerUrl).then(res =\u003e res.text());\n\n  // 2. Extract and decode cid\n  const cidHex = /cid:\\s*'([^']+)'/.exec(html)?.[1];\n  if (!cidHex) throw new Error(\"cid not found\");\n\n  const cidDecoded = hexToUtf8(cidHex);\n  const [ip, route] = cidDecoded.split(\"|\");\n\n  const id = new URL(playerUrl).searchParams.get(\"id\");\n  const userAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0\";\n  const timestamp = Math.floor(Date.now() / 1000);\n  const expire = timestamp + 600;\n\n  const finalRoute = route.replace(\"player.php\", \"source.php\");\n\n  // 3. Request SHA1 signature from Worker\n  const fullString = ip + userAgent + finalRoute + id + expire + \"e13d38099bf562e8b9851a652d2043d3\"\n  const signature = await sha1(fullString);\n\n  if (!signature || signature.length !== 40) {\n    throw new Error(\"Invalid signature returned from Worker\");\n  }\n\n  const host = new URL(playerUrl).host;\n  const sourceUrl = `https://${host}${finalRoute}?id=${id}\u0026e=${expire}\u0026s=${signature}`;\n\n  // 4. Fetch and parse the encrypted response\n  const sourceHtml = await fetch(sourceUrl, {\n    headers: {\n      \"Referer\": playerUrl,\n      \"User-Agent\": userAgent\n    },\n  });\n  \n  const encryptedData = await sourceHtml.json()\n\n  const [encryptedBase64, ivHex] = encryptedData.data.split(\":\");\n\n  const decryptedJson = decryptVidstreamingPayload(encryptedBase64, ivHex, \"e13d38099bf562e8b9851a652d2043d3\");\n  \n  const decryptedData = JSON.parse(decryptedJson);\n\n  const fixedM3u8 = decryptedData.hls.replace(/^\\/\\//, \"https://\");\n\n  return {\n    m3u8: fixedM3u8,\n    subtitles: (decryptedData.subtitles || []).map(sub =\u003e ({\n      id: sub.language,\n      label: sub.name,\n      file: sub.src.startsWith(\"//\") \n        ? `https:${sub.src}` \n        : sub.src.startsWith(\"/\") \n          ? `https://${host}${sub.src}` \n          : sub.src\n    }))\n  };\n}\n\nfunction hexToUtf8(hex) {\n  return decodeURIComponent(hex.replace(/(..)/g, \"%$1\"));\n}\n\nfunction decryptVidstreamingPayload(encryptedBase64: string, ivHex: string, keyStr: string) {\n  const key = CryptoJS.enc.Utf8.parse(keyStr);\n  const iv = CryptoJS.enc.Hex.parse(ivHex);\n\n  const decrypted = CryptoJS.AES.decrypt(encryptedBase64, key, { iv: iv });\n\n  return decrypted.toString(CryptoJS.enc.Utf8);\n}\n\nfunction sha1(msg) {\n  // --- UTF-8 encode (no Web APIs)\n  function utf8Bytes(str) {\n    // robust and compact\n    var s = unescape(encodeURIComponent(str));\n    var arr = new Uint8Array(s.length);\n    for (var i = 0; i \u003c s.length; i++) arr[i] = s.charCodeAt(i);\n    return arr;\n  }\n\n  function rotl(x, n) { return (x \u003c\u003c n) | (x \u003e\u003e\u003e (32 - n)); }\n  function hex(n) { return (n \u003e\u003e\u003e 0).toString(16).padStart(8, '0'); }\n\n  var K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];\n  var H0 = 0x67452301, H1 = 0xEFCDAB89, H2 = 0x98BADCFE, H3 = 0x10325476, H4 = 0xC3D2E1F0;\n\n  var m = utf8Bytes(msg);\n  var ml = m.length;\n\n  // --- padding: 0x80, zeros, then 64-bit length (we write low 32 for \u003c 2^32 bits)\n  var len = ((ml + 9 + 63) \u003e\u003e 6) \u003c\u003c 6;           // multiple of 64\n  var buf = new Uint8Array(len);\n  buf.set(m);\n  buf[ml] = 0x80;\n  var bitLen = ml * 8;\n  buf[len - 4] = (bitLen \u003e\u003e\u003e 24) \u0026 0xff;\n  buf[len - 3] = (bitLen \u003e\u003e\u003e 16) \u0026 0xff;\n  buf[len - 2] = (bitLen \u003e\u003e\u003e  8) \u0026 0xff;\n  buf[len - 1] = (bitLen \u003e\u003e\u003e  0) \u0026 0xff;\n\n  var w = new Int32Array(80);\n\n  for (var i = 0; i \u003c buf.length; i += 64) {\n    for (var j = 0; j \u003c 16; j++) {\n      var idx = i + j * 4;\n      w[j] = (buf[idx] \u003c\u003c 24) | (buf[idx+1] \u003c\u003c 16) | (buf[idx+2] \u003c\u003c 8) | (buf[idx+3]);\n    }\n    for (j = 16; j \u003c 80; j++) {\n      var t = w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16];\n      w[j] = (t \u003c\u003c 1) | (t \u003e\u003e\u003e 31);\n    }\n\n    var a = H0 | 0, b = H1 | 0, c = H2 | 0, d = H3 | 0, e = H4 | 0;\n\n    for (j = 0; j \u003c 80; j++) {\n      var s = (j / 20) | 0;\n      var f = s === 0 ? (b \u0026 c) | (~b \u0026 d)\n            : s === 2 ? (b \u0026 c) | (b \u0026 d) | (c \u0026 d)\n            :            (b ^ c ^ d);\n      var temp = (rotl(a, 5) + f + e + K[s] + (w[j] | 0)) | 0;\n      e = d;\n      d = c;\n      c = rotl(b, 30) | 0;\n      b = a;\n      a = temp;\n    }\n\n    H0 = (H0 + a) | 0;\n    H1 = (H1 + b) | 0;\n    H2 = (H2 + c) | 0;\n    H3 = (H3 + d) | 0;\n    H4 = (H4 + e) | 0;\n  }\n\n  return hex(H0) + hex(H1) + hex(H2) + hex(H3) + hex(H4);\n}"
}
