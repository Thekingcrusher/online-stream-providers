{
  "id":"hianime",
  "name":"HiAnime",
  "version":"1.1.0",
  "manifestURI":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/manifest.json",
  "language":"typescript",
  "type":"onlinestream-provider",
  "description":"HiAnime is an online stream provider for both sub and dub with soft subs.",
  "author":"Thekingcrusher",
  "icon":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/logo.png",
  "lang":"en",
  "payload": "/// \u003creference path=\"./online-streaming-provider.d.ts\" /\u003e\n\nclass Provider {\n  baseUrl = \"https://hianime.to\"\n\n  getSettings(): Settings {\n      return {\n          episodeServers: [\"HD-1\", \"HD-2\", \"HD-3\"],\n          supportsDub: true\n      }\n  }\n\n  async search(query: SearchOptions): Promise\u003cSearchResult[]\u003e {\n    // --- normalize helpers ---\n    const normalize = (title) =\u003e {\n      return (title || \"\")\n        .toLowerCase()\n        .replace(/(season|cour|part)/g, \"\") // strip keywords\n        .replace(/\\d+(st|nd|rd|th)/g, (m) =\u003e m.replace(/st|nd|rd|th/, \"\")) // remove ordinal suffixes\n        .replace(/[^a-z0-9]+/g, \"\") // remove non-alphanumeric\n        .replace(/(?\u003c!i)ii(?!i)/g, \"2\") // replace II with 2\n    };\n\n    const normalizeTitle = (title) =\u003e {\n      return (title || \"\")\n        .toLowerCase()\n        .replace(/(season|cour|part|uncensored)/g, \"\") // strip keywords\n        .replace(/\\d+(st|nd|rd|th)/g, (m) =\u003e m.replace(/st|nd|rd|th/, \"\")) // remove ordinal suffixes\n        .replace(/[^a-z0-9]+/g, \"\"); // remove non-alphanumeric\n    };\n\n    const decodeHtmlEntities = (str) =\u003e {\n      return (str || \"\")\n        .replace(/\\\\u0026/g, \"\u0026\")     // convert \\u0026 to \u0026\n        .replace(/\u0026#(\\d+);?/g, (m, dec) =\u003e String.fromCharCode(dec))\n        .replace(/\u0026quot;/g, '\"')\n        .replace(/\u0026apos;/g, \"'\")\n        .replace(/\u0026amp;/g, \"\u0026\")\n        .replace(/\u0026lt;/g, \"\u003c\")\n        .replace(/\u0026gt;/g, \"\u003e\");\n    }\n\n    const levenshteinSimilarity = (a, b) =\u003e {\n      const lenA = a.length;\n      const lenB = b.length;\n      const dp = Array.from({ length: lenA + 1 }, () =\u003e new Array(lenB + 1).fill(0));\n    \n      for (let i = 0; i \u003c= lenA; i++) dp[i][0] = i;\n      for (let j = 0; j \u003c= lenB; j++) dp[0][j] = j;\n    \n      for (let i = 1; i \u003c= lenA; i++) {\n        for (let j = 1; j \u003c= lenB; j++) {\n          if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n          else dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n        }\n      }\n    \n      const distance = dp[lenA][lenB];\n      const maxLen = Math.max(lenA, lenB);\n      return 1 - distance / maxLen; // similarity in range [0,1]\n    };\n\n    const start = query.media.startDate;\n    const targetNormJP = normalize(query.media.romajiTitle);\n    const targetNorm = query.media.englishTitle ? normalize(query.media.englishTitle) : targetNormJP;\n  \n    const fetchMatches = async (url: string) =\u003e {\n      const reply = await fetch(url).then(r =\u003e r.json());\n      const html  = reply.html;\n    \n      // Match \u003ca href=\"/something-id\" class=\"nav-item\"\u003e but exclude bottom links\n      const regex = /\u003ca href=\"\\/([^\"]+)\" class=\"nav-item\"\u003e[\\s\\S]*?\u003ch3 class=\"film-name\"[^\u003e]*data-jname=\"([^\"]+)\"[^\u003e]*\u003e([^\u003c]+)\u003c\\/h3\u003e[\\s\\S]*?\u003cdiv class=\"film-infor\"\u003e\\s*\u003cspan\u003e([^\u003c]+)\u003c\\/span\u003e/g;\n\n      const monthMap: Record\u003cstring, number\u003e = {\n        Jan: 1, Feb: 2, Mar: 3, Apr: 4, May: 5, Jun: 6,\n        Jul: 7, Aug: 8, Sep: 9, Oct: 10, Nov: 11, Dec: 12,\n      };\n    \n      const matches = [...html.matchAll(regex)]\n        .map(m =\u003e {\n          const pageUrl = m[1]; // e.g., my-star-18330\n          if (pageUrl.startsWith(\"search?\")) return null; // exclude \"View all results\"\n    \n          const jname = m[2]?.trim();\n          const title = m[3]?.trim();\n          const dateStr = m[4].trim(); // e.g. \"Jul 4, 2025\"\n\n          let startDate = { year: 0, month: 0, day: 0 };\n          const dateMatch = dateStr.match(/([A-Za-z]+)\\s+(\\d{1,2}),\\s*(\\d{4})/);\n          if (dateMatch) {\n            const month = monthMap[dateMatch[1]];\n            const day = parseInt(dateMatch[2]);\n            const year = parseInt(dateMatch[3]);\n            startDate = { year, month, day };\n          }\n    \n          // Extract numeric ID if it exists (e.g., my-star-18330 → 18330)\n          const idMatch = pageUrl.match(/-(\\d+)$/);\n          const id = idMatch ? idMatch[1] : pageUrl;\n    \n          return {\n            id,\n            pageUrl,\n            title: decodeHtmlEntities(title),\n            normTitleJP: normalize(decodeHtmlEntities(jname)),\n            normTitle: normalize(decodeHtmlEntities(title)),\n            startDate,\n          };\n        })\n        .filter(Boolean); // remove null entries\n    \n      return matches;\n    };\n  \n    // Base search\n    const url = `${this.baseUrl}/ajax/search/suggest?keyword=${encodeURIComponent(query.query)}`;\n    const matches = await fetchMatches(url);\n  \n    if (matches.length === 0) return [];\n\n    // Filter results prioritizing from -\u003e match title \u0026 start year/month -\u003e match title \u0026 start year\n    let filtered = matches.filter(m =\u003e {\n      const titleMatch =\n        m.normTitle === targetNorm ||\n        m.normTitleJP === targetNormJP;\n\n      const dateMatch =\n        (m.startDate?.year === start?.year) \u0026\u0026\n        (m.startDate?.month === start?.month);\n\n      return titleMatch \u0026\u0026 dateMatch;\n    });\n\n    if (!filtered.length) {\n      filtered = matches.filter(m =\u003e {\n        const titleMatch =\n          m.normTitle === targetNorm ||\n          m.normTitleJP === targetNormJP;\n\n        const dateMatch =\n          (m.startDate?.year === start?.year)\n        \n        return titleMatch \u0026\u0026 dateMatch;\n      });\n    }\n\n    if (!filtered.length) {\n      filtered = matches.filter(m =\u003e {\n        const titleMatch =\n          m.normTitle.includes(targetNorm) ||\n          m.normTitleJP.includes(targetNormJP) ||\n          targetNorm.includes(m.normTitle) ||\n          targetNormJP.includes(m.normTitleJP) ||\n          levenshteinSimilarity(m.normTitle, targetNorm) \u003e 0.7 ||\n          levenshteinSimilarity(m.normTitleJP, targetNormJP) \u003e 0.7;\n\n        const dateMatch =\n          (m.startDate?.year === start?.year) \u0026\u0026\n          (m.startDate?.month === start?.month);\n        \n        return titleMatch \u0026\u0026 dateMatch;\n      });\n    }\n\n    if (!filtered.length) {\n      filtered = matches.filter(m =\u003e {\n        const titleMatch =\n          m.normTitle.includes(targetNorm) ||\n          m.normTitleJP.includes(targetNormJP) ||\n          targetNorm.includes(m.normTitle) ||\n          targetNormJP.includes(m.normTitleJP) ||\n          levenshteinSimilarity(m.normTitle, targetNorm) \u003e 0.7 ||\n          levenshteinSimilarity(m.normTitleJP, targetNormJP) \u003e 0.7;\n\n        const dateMatch =\n          (m.startDate?.year === start?.year)\n        \n        return titleMatch \u0026\u0026 dateMatch;\n      });\n    }\n  \n    // Return results\n    let results = filtered.map(m =\u003e ({\n      id: `${m.id}/${query.dub ? \"dub\" : \"sub\"}`,\n      title: m.title,\n      url: `${this.baseUrl}/${m.pageUrl}`,\n      subOrDub: query.dub ? \"dub\" : \"sub\",\n    }));\n\n    if (!query.media.startDate || !query.media.startDate.year) {\n      const fetchMatches = async (url: string) =\u003e {\n        const html = await fetch(url).then(res =\u003e res.text());\n        // Match the main link\n        const regex = /\u003ca href=\"\\/watch\\/([^\"]+)\"[^\u003e]+title=\"([^\"]+)\"[^\u003e]+data-id=\"(\\d+)\"/g;\n        return [...html.matchAll(regex)].map(m =\u003e {\n          const id = m[3];\n          const pageUrl = m[1];\n          const title = m[2];\n          // Find corresponding data-jname\n          const jnameRegex = new RegExp(\n            `\u003ch3 class=\"film-name\"\u003e[\\\\s\\\\S]*?\u003ca[^\u003e]+href=\"\\\\/${pageUrl}[^\"]*\"[^\u003e]+data-jname=\"([^\"]+)\"`,\n            \"i\"\n          );\n          const jnameMatch = html.match(jnameRegex);\n          const jname = jnameMatch ? jnameMatch[1] : null;\n          return {\n            id,\n            pageUrl,\n            title: decodeHtmlEntities(title),\n            normTitleJP: normalizeTitle(decodeHtmlEntities(jname)),\n            normTitle: normalizeTitle(decodeHtmlEntities(title)),\n          };\n        });\n      };\n    \n      // Base search\n      const url = `${this.baseUrl}/search?keyword=${encodeURIComponent(query.query)}`;\n      const matches = await fetchMatches(url);\n      \n      filtered = matches.filter(m =\u003e {\n        const titleMatch =\n          m.normTitle === normalizeTitle(query.query) ||\n          m.normTitleJP === normalizeTitle(query.query) ||\n          m.normTitle.includes(normalizeTitle(query.query)) ||\n          m.normTitleJP.includes(normalizeTitle(query.query)) ||\n          normalizeTitle(query.query).includes(m.normTitle) ||\n          normalizeTitle(query.query).includes(m.normTitleJP);\n        return titleMatch;\n      });\n      filtered.sort((a, b) =\u003e {\n        const A = normalizeTitle(a.title);\n        const B = normalizeTitle(b.title);\n      \n        // 1) Sort by length\n        if (A.length !== B.length) {\n          return A.length - B.length;\n        }\n      \n        // 2) If lengths match, sort alphabetically\n        return A.localeCompare(B);\n      });\n      results = filtered.map(m =\u003e ({\n        id: `${m.id}/${query.dub ? \"dub\" : \"sub\"}`,\n        title: m.title,\n        url: `${this.baseUrl}/${m.pageUrl}`,\n        subOrDub: query.dub ? \"dub\" : \"sub\",\n      }));\n    }\n\n    return results;\n  }\n\n  async findEpisodes(animeId: string): Promise\u003cEpisodeDetails[]\u003e {\n    const [id, subOrDub] = animeId.split(\"/\");\n    const res = await fetch(`${this.baseUrl}/ajax/v2/episode/list/${id}`, {\n      headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n    });\n    const json = await res.json();\n    const html = json.html;\n\n    const episodes = [];\n    const regex = /\u003ca[^\u003e]*class=\"[^\"]*\\bep-item\\b[^\"]*\"[^\u003e]*data-number=\"(\\d+)\"[^\u003e]*data-id=\"(\\d+)\"[^\u003e]*href=\"([^\"]+)\"[\\s\\S]*?\u003cdiv class=\"ep-name[^\"]*\"[^\u003e]*title=\"([^\"]+)\"/g;\n\n    let match;\n    while ((match = regex.exec(html)) !== null) {\n      episodes.push({\n        id: `${match[2]}/${subOrDub}`, // episode's internal ID\n        number: parseInt(match[1], 10),\n        url: this.baseUrl+match[3],\n        title: match[4],\n      });\n    }\n\n    return episodes;\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n    const [id, subOrDub] = episode.id.split(\"/\");\n    let serverName = _server !== \"default\" ? _server : \"HD-1\";\n    \n    // Fetch server list\n    const serverJson = await fetch(`${this.baseUrl}/ajax/v2/episode/servers?episodeId=${id}`, {\n        headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n    }).then(res =\u003e res.json());\n    \n    const serverHtml = serverJson.html;\n\n    // Regex to match the right block (sub or dub) and find the server by name\n    const regex = new RegExp(\n        `\u003cdiv[^\u003e]*class=\"item server-item\"[^\u003e]*data-type=\"${subOrDub}\"[^\u003e]*data-id=\"(\\\\d+)\"[^\u003e]*\u003e\\\\s*\u003ca[^\u003e]*\u003e\\\\s*${serverName}\\\\s*\u003c/a\u003e`,\n        \"i\"\n    );\n\n    const match = regex.exec(serverHtml);\n    if (!match) throw new Error(`Server \"${serverName}\" (${subOrDub}) not found`);\n\n    const serverId = match[1];\n\n    // Fetch source embed\n    const sourcesJson = await fetch(`${this.baseUrl}/ajax/v2/episode/sources?id=${serverId}`, {\n        headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n    }).then(res =\u003e res.json());\n\n    let decryptData = null;\n\n    try {\n      decryptData = await extractMegaCloud(sourcesJson.link);\n    } catch (err) {\n      console.warn(\"Primary decrypter failed:\", err);\n    }\n    \n    // Fallback to ShadeOfChaos if primary fails or no valid data\n    if (!decryptData) {\n      console.warn(\"Primary decrypter failed — trying ShadeOfChaos fallback...\");\n      const fallbackRes = await fetch(\n        `https://ac-api.ofchaos.com/api/anime/embed/convert/v2?embedUrl=${encodeURIComponent(sourcesJson.link)}`\n      );\n      decryptData = await fallbackRes.json();\n    }\n\n    // Get HLS or MP4 stream\n    const streamSource =\n      decryptData.sources.find((s: any) =\u003e s.type === \"hls\") ||\n      decryptData.sources.find((s: any) =\u003e s.type === \"mp4\");\n  \n    if (!streamSource?.file) throw new Error(\"No valid stream file found\");\n  \n    // Map subtitles\n    const subtitles =\n      (decryptData.tracks || [])\n        .filter((t: any) =\u003e t.kind === \"captions\")\n        .map((track: any, index: number) =\u003e ({\n          id: `sub-${index}`,\n          language: track.label || \"Unknown\",\n          url: track.file,\n          isDefault: !!track.default,\n        }));\n  \n      return {\n        server: serverName,\n        headers: {\n          \"Referer\": \"https://megacloud.club/\",\n          \"Origin\": \"https://megacloud.club\",\n          \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n        },\n        videoSources: [{\n            url: streamSource.file,\n            type: streamSource.type === \"hls\" ? \"m3u8\" : \"mp4\",\n            quality: \"auto\",\n            subtitles\n        }]\n    };\n  }\n}\n\nasync function extractMegaCloud(embedUrl: string) {\n  const url = new URL(embedUrl);\n  const baseDomain = `${url.protocol}//${url.host}/`;\n\n  const headers = {\n    \"Accept\": \"*/*\",\n    \"X-Requested-With\": \"XMLHttpRequest\",\n    \"Referer\": baseDomain,\n    \"User-Agent\":\n      \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36\",\n  };\n\n  // Fetch embed page\n  const html = await fetch(embedUrl, { headers }).then((r) =\u003e r.text());\n\n  // Extract file ID\n  const fileIdMatch = html.match(/\u003ctitle\u003e\\s*File\\s+#([a-zA-Z0-9]+)\\s*-/i);\n  if (!fileIdMatch) throw new Error(\"file_id not found in embed page\");\n  const fileId = fileIdMatch[1];\n\n  // Extract nonce\n  let nonce: string | null = null;\n  const match48 = html.match(/\\b[a-zA-Z0-9]{48}\\b/);\n  if (match48) nonce = match48[0];\n  else {\n    const match3x16 = [...html.matchAll(/[\"']([A-Za-z0-9]{16})[\"']/g)];\n    if (match3x16.length \u003e= 3) {\n      nonce = match3x16[0][1] + match3x16[1][1] + match3x16[2][1];\n    }\n  }\n  if (!nonce) throw new Error(\"nonce not found\");\n\n  // Fetch sources\n  const sourcesJson = await fetch(\n    `${baseDomain}embed-2/v3/e-1/getSources?id=${fileId}\u0026_k=${nonce}`,\n    { headers }\n  ).then((r) =\u003e r.json());\n\n  return {\n    sources: sourcesJson.sources,\n    tracks: sourcesJson.tracks || [],\n    intro: sourcesJson.intro || null,\n    outro: sourcesJson.outro || null,\n    server: sourcesJson.server || null,\n  };\n}"
}
