{
  "id":"hianime",
  "name":"HiAnime",
  "version":"1.0.1",
  "manifestURI":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/manifest.json",
  "language":"typescript",
  "type":"onlinestream-provider",
  "description":"HiAnime is an online stream provider for both sub and dub with soft subs.",
  "author":"Thekingcrusher",
  "icon":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/logo.png",
  "lang":"en",
  "payload": "/// \u003creference path=\"./online-streaming-provider.d.ts\" /\u003e\n\nclass Provider {\n    baseUrl = \"https://hianime.to\"\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"HD-1\", \"HD-2\", \"HD-3\", \"HD-4\"],\n            supportsDub: true\n        }\n    }\n\n    async search(query: SearchOptions): Promise\u003cSearchResult[]\u003e {\n      const normalize = (str: string) =\u003e\n        str.toLowerCase().replace(/[^a-z0-9]+/g, \"\"); // remove special chars \u0026 spaces\n    \n      const start = query.media.startDate;\n    \n      // Base search (no date filter)\n      let url = `${this.baseUrl}/search?keyword=${encodeURIComponent(query.query)}`;\n      let html = await fetch(url).then(res =\u003e res.text());\n    \n      const regex = /\u003ca href=\"\\/watch\\/([^\"]+)\"[^\u003e]+title=\"([^\"]+)\"[^\u003e]+data-id=\"(\\d+)\"/;\n      let match = html.match(regex);\n    \n      if (!match) return [];\n    \n      let id = match[3];\n      let pageUrl = match[1];\n      let title = match[2];\n    \n      // If normalized titles don't match, retry with year/month/day filter\n      if (normalize(title) !== normalize(query.query)) {\n        url = `${this.baseUrl}/search?keyword=${encodeURIComponent(query.query)}\u0026sy=${start.year}\u0026sm=${start.month}\u0026sd=${start.day}\u0026sort=default`;\n        html = await fetch(url).then(res =\u003e res.text());\n        match = html.match(regex);\n    \n        if (!match) return [];\n    \n        id = match[3];\n        pageUrl = match[1];\n        title = match[2];\n      }\n    \n      return [\n        {\n          id: `${id}/${query.dub ? \"dub\" : \"sub\"}`,\n          title,\n          url: `${this.baseUrl}/${pageUrl}`,\n          subOrDub: \"both\",\n        },\n      ];\n    }\n\n    async findEpisodes(animeId: string): Promise\u003cEpisodeDetails[]\u003e {\n      const [id, subOrDub] = animeId.split(\"/\");\n      const res = await fetch(`${this.baseUrl}/ajax/v2/episode/list/${id}`, {\n          headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n      });\n      const json = await res.json();\n      const html = json.html;\n  \n      const episodes = [];\n      const regex = /\u003ca[^\u003e]*class=\"ssl-item\\s+ep-item\"[^\u003e]*data-number=\"(\\d+)\"[^\u003e]*data-id=\"(\\d+)\"[^\u003e]*href=\"([^\"]+)\"[\\s\\S]*?\u003cdiv class=\"ep-name[^\"]*\"[^\u003e]*title=\"([^\"]+)\"/g;\n  \n      let match;\n      while ((match = regex.exec(html)) !== null) {\n          episodes.push({\n              id: `${match[2]}/${subOrDub}`, // episode's internal ID\n              number: parseInt(match[1], 10),\n              url: this.baseUrl+match[3],\n              title: match[4],\n          });\n      }\n  \n      return episodes;\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n      const [id, subOrDub] = episode.id.split(\"/\");\n      let serverName = _server !== \"default\" ? _server : \"HD-1\";\n\n      if (_server === \"HD-1\" || _server === \"HD-2\" || _server === \"HD-3\") {\n        // Fetch server list\n        const serverJson = await fetch(`${this.baseUrl}/ajax/v2/episode/servers?episodeId=${id}`, {\n            headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n        }).then(res =\u003e res.json());\n        \n        const serverHtml = serverJson.html;\n    \n        // Regex to match the right block (sub or dub) and find the server by name\n        const regex = new RegExp(\n            `\u003cdiv[^\u003e]*class=\"item server-item\"[^\u003e]*data-type=\"${subOrDub}\"[^\u003e]*data-id=\"(\\\\d+)\"[^\u003e]*\u003e\\\\s*\u003ca[^\u003e]*\u003e\\\\s*${serverName}\\\\s*\u003c/a\u003e`,\n            \"i\"\n        );\n    \n        const match = regex.exec(serverHtml);\n        if (!match) throw new Error(`Server \"${serverName}\" (${subOrDub}) not found`);\n    \n        const serverId = match[1];\n    \n        // Fetch source embed\n        const sourcesJson = await fetch(`${this.baseUrl}/ajax/v2/episode/sources?id=${serverId}`, {\n            headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n        }).then(res =\u003e res.json());\n\n        let decryptData = null;\n\n        try {\n          decryptData = await extractMegaCloud(sourcesJson.link);\n        } catch (err) {\n          console.warn(\"Primary decrypter failed:\", err);\n        }\n        \n        // Fallback to ShadeOfChaos if primary fails or no valid data\n        if (!decryptData) {\n          console.warn(\"Primary decrypter failed â€” trying ShadeOfChaos fallback...\");\n          const fallbackRes = await fetch(\n            `https://ac-api.ofchaos.com/api/anime/embed/convert/v2?embedUrl=${encodeURIComponent(sourcesJson.link)}`\n          );\n          decryptData = await fallbackRes.json();\n        }\n    \n        // Get HLS or MP4 stream\n        const streamSource =\n          decryptData.sources.find((s: any) =\u003e s.type === \"hls\") ||\n          decryptData.sources.find((s: any) =\u003e s.type === \"mp4\");\n      \n        if (!streamSource?.file) throw new Error(\"No valid stream file found\");\n      \n        // Map subtitles\n        const subtitles =\n          (decryptData.tracks || [])\n            .filter((t: any) =\u003e t.kind === \"captions\")\n            .map((track: any, index: number) =\u003e ({\n              id: `sub-${index}`,\n              language: track.label || \"Unknown\",\n              url: track.file,\n              isDefault: !!track.default,\n            }));\n      \n          return {\n              server: serverName,\n              headers: {\n                \"Referer\": \"https://megacloud.club/\",\n                \"Origin\": \"https://megacloud.club\",\n                \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n              },\n              videoSources: [{\n                  url: streamSource.file,\n                  type: streamSource.type === \"hls\" ? \"m3u8\" : \"mp4\",\n                  quality: \"auto\",\n                  subtitles\n              }]\n          };\n        }\n      \n    else if (_server === \"HD-4\") {\n      // Fetch Iframe\n      const iframe = await fetch(\n        `https://megaplay.buzz/stream/s-2/${id}/${subOrDub}`,\n          {\n              headers: {\n                  Referer: \"https://megaplay.buzz/api\",\n              },\n          }\n      );\n      if (!iframe.ok) throw new Error(\"Episode is not available\");\n\n      // Parse dataId\n      const iframeBody = await iframe.text();\n      const dataIdMatch = iframeBody.match(/\u003ctitle\u003e\\s*File\\s+(\\d+)\\s*-\\s*MegaPlay/i);\n      if (!dataIdMatch) throw new Error(\"data-id not found\");\n      const dataId = dataIdMatch[1];\n      \n      // Fetch HLS stream\n      const fetchData = await fetch(`https://megaplay.buzz/stream/getSources?id=${dataId}\u0026id=${dataId}`, {\n          headers: {\n              \"X-Requested-With\": \"XMLHttpRequest\",\n          }\n      }).then(res =\u003e res.json());\n    \n      // Map subtitles\n      const subtitles =\n        (fetchData.tracks || [])\n          .filter((t: any) =\u003e t.kind === \"captions\")\n          .map((track: any, index: number) =\u003e ({\n            id: `sub-${index}`,\n            language: track.label || \"Unknown\",\n            url: track.file,\n            isDefault: !!track.default,\n          }));\n\n      return {\n            server: serverName,\n            headers: {\n              'Accept': '*/*',\n              'Accept-Language': 'en-US,en;q=0.5',\n              \"Referer\": `https://megaplay.buzz/`,\n              \"Origin\": \"https://megaplay.buzz\",\n              'Sec-Fetch-Dest': 'empty',\n              'Sec-Fetch-Mode': 'cors',\n              'Sec-Fetch-Site': 'cross-site',\n              'Te': 'trailers',\n              \"User-Agent\":\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n            },\n            videoSources: [{\n                url: fetchData.sources?.file,\n                type: \"m3u8\",\n                quality: \"auto\",\n                subtitles\n            }]\n        };\n    }\n  }\n}\n\nasync function extractMegaCloud(embedUrl: string) {\n  const url = new URL(embedUrl);\n  const baseDomain = `${url.protocol}//${url.host}/`;\n\n  const headers = {\n    \"Accept\": \"*/*\",\n    \"X-Requested-With\": \"XMLHttpRequest\",\n    \"Referer\": baseDomain,\n    \"User-Agent\":\n      \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36\",\n  };\n\n  // Fetch embed page\n  const html = await fetch(embedUrl, { headers }).then((r) =\u003e r.text());\n\n  // Extract file ID\n  const fileIdMatch = html.match(/\u003ctitle\u003e\\s*File\\s+#([a-zA-Z0-9]+)\\s*-/i);\n  if (!fileIdMatch) throw new Error(\"file_id not found in embed page\");\n  const fileId = fileIdMatch[1];\n\n  // Extract nonce\n  let nonce: string | null = null;\n  const match48 = html.match(/\\b[a-zA-Z0-9]{48}\\b/);\n  if (match48) nonce = match48[0];\n  else {\n    const match3x16 = [...html.matchAll(/[\"']([A-Za-z0-9]{16})[\"']/g)];\n    if (match3x16.length \u003e= 3) {\n      nonce = match3x16[0][1] + match3x16[1][1] + match3x16[2][1];\n    }\n  }\n  if (!nonce) throw new Error(\"nonce not found\");\n\n  // Get key\n  const keyUrl =\n    \"https://raw.githubusercontent.com/yogesh-hacker/MegacloudKeys/refs/heads/main/keys.json\";\n  const keyJson = await fetch(keyUrl).then((res) =\u003e res.json());\n  const key = keyJson.mega;\n\n  // Fetch sources\n  const sourcesJson = await fetch(\n    `${baseDomain}embed-2/v3/e-1/getSources?id=${fileId}\u0026_k=${nonce}`,\n    { headers }\n  ).then((r) =\u003e r.json());\n\n  return {\n    sources: sourcesJson.sources,\n    tracks: sourcesJson.tracks || [],\n    intro: sourcesJson.intro || null,\n    outro: sourcesJson.outro || null,\n    server: sourcesJson.server || null,\n  };\n}"
}
