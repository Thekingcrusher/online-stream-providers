{
  "id":"hianime",
  "name":"HiAnime",
  "version":"1.0.0",
  "manifestURI":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/manifest.json",
  "language":"typescript",
  "type":"onlinestream-provider",
  "description":"HiAnime is an online stream provider for both sub and dub with soft subs.",
  "author":"Thekingcrusher",
  "icon":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/logo.png",
  "lang":"en",
  "payload": "/// \u003creference path=\"./online-streaming-provider.d.ts\" /\u003e\n\nclass Provider {\n    baseUrl = \"https://hianime.to\"\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"HD-1\", \"HD-2\", \"HD-3\", \"HD-4\"],\n            supportsDub: true\n        }\n    }\n\n    async search(query: SearchOptions): Promise\u003cSearchResult[]\u003e {\n      const url = `${this.baseUrl}/search?keyword=${encodeURIComponent(query.query)}`;\n      const html = await fetch(url).then(res =\u003e res.text());\n\n      const results: SearchResult[] = [];\n      const regex = /\u003ca href=\"\\/watch\\/([^\"]+)\"[^\u003e]+title=\"([^\"]+)\"[^\u003e]+data-id=\"(\\d+)\"/g;\n      let match;\n      while ((match = regex.exec(html)) !== null) {\n        const id = match[3];\n        const url = match[1];\n        const title = match[2];\n        results.push({\n          \n          id: `${id}/${query.dub ? \"dub\" : \"sub\"}`,\n          title,\n          url: `${this.baseUrl}/${url}`,\n          subOrDub: \"both\"\n        });\n      }\n      return results;\n    }\n\n    async findEpisodes(animeId: string): Promise\u003cEpisodeDetails[]\u003e {\n      const [id, subOrDub] = animeId.split(\"/\");\n      const res = await fetch(`${this.baseUrl}/ajax/v2/episode/list/${id}`, {\n          headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n      });\n      const json = await res.json();\n      const html = json.html;\n  \n      const episodes = [];\n      const regex = /\u003ca[^\u003e]*class=\"ssl-item\\s+ep-item\"[^\u003e]*data-number=\"(\\d+)\"[^\u003e]*data-id=\"(\\d+)\"[^\u003e]*href=\"([^\"]+)\"[\\s\\S]*?\u003cdiv class=\"ep-name[^\"]*\"[^\u003e]*title=\"([^\"]+)\"/g;\n  \n      let match;\n      while ((match = regex.exec(html)) !== null) {\n          episodes.push({\n              id: `${match[2]}/${subOrDub}`, // episode's internal ID\n              number: parseInt(match[1], 10),\n              url: this.baseUrl+match[3],\n              title: match[4],\n          });\n      }\n  \n      return episodes;\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n      const [id, subOrDub] = episode.id.split(\"/\");\n      const [base, url] = episode.url.split(\"/watch/\")\n      let serverName = _server !== \"default\" ? _server : \"HD-1\";\n\n      if (_server === \"HD-1\" || _server === \"HD-2\" || _server === \"HD-3\") {\n        // Fetch server list\n        const serverJson = await fetch(`${this.baseUrl}/ajax/v2/episode/servers?episodeId=${id}`, {\n            headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n        }).then(res =\u003e res.json());\n        \n        const serverHtml = serverJson.html;\n    \n        // Regex to match the right block (sub or dub) and find the server by name\n        const regex = new RegExp(\n            `\u003cdiv[^\u003e]*class=\"item server-item\"[^\u003e]*data-type=\"${subOrDub}\"[^\u003e]*data-id=\"(\\\\d+)\"[^\u003e]*\u003e\\\\s*\u003ca[^\u003e]*\u003e\\\\s*${serverName}\\\\s*\u003c/a\u003e`,\n            \"i\"\n        );\n    \n        const match = regex.exec(serverHtml);\n        if (!match) throw new Error(`Server \"${serverName}\" (${subOrDub}) not found`);\n    \n        const serverId = match[1];\n    \n        // Fetch source embed\n        const sourcesJson = await fetch(`${this.baseUrl}/ajax/v2/episode/sources?id=${serverId}`, {\n            headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n        }).then(res =\u003e res.json());\n  \n        const normalizeDecrypterOutput = (json: any) =\u003e {\n        if (!json) return null;\n        if (json.result?.sources?.length) {\n          return {\n            sources: json.result.sources,\n            tracks: json.result.tracks || [],\n          };\n        }\n        if (json.data?.sources?.length) {\n          return {\n            sources: json.data.sources,\n            tracks: json.data.tracks || [],\n          };\n        }\n        return null;\n      };\n  \n      // Try primary decrypter\n      let decryptData = null;\n      try {\n        const decryptRes = await fetch(\n          `https://ac-api.ofchaos.com/api/anime/embed/convert/v2?embedUrl=${encodeURIComponent(sourcesJson.link)}`\n        );\n        const decryptJson = await decryptRes.json();\n        decryptData = normalizeDecrypterOutput(decryptJson);\n      } catch (err) {\n        console.warn(\"Primary decrypter failed:\", err);\n      }\n    \n      // Fallback to Zenime if primary fails or no valid data\n      if (!decryptData) {\n        console.warn(\"Primary decrypter failed â€” trying Zenime fallback...\");\n        const fallbackRes = await fetch(\n          `https://decrypt.zenime.site/extract?embed_url=${encodeURIComponent(sourcesJson.link)}?k=1\u0026autoPlay=0\u0026oa=0\u0026asi=1`\n        );\n        const fallbackJson = await fallbackRes.json();\n        decryptData = normalizeDecrypterOutput(fallbackJson);\n      }\n    \n      // Still nothing? Fail\n      if (!decryptData) throw new Error(\"No video sources from any decrypter\");\n    \n      // Get HLS or MP4 stream\n      const streamSource =\n        decryptData.sources.find((s: any) =\u003e s.type === \"hls\") ||\n        decryptData.sources.find((s: any) =\u003e s.type === \"mp4\");\n    \n      if (!streamSource?.file) throw new Error(\"No valid stream file found\");\n    \n      // Map subtitles\n      const subtitles =\n        (decryptData.tracks || [])\n          .filter((t: any) =\u003e t.kind === \"captions\")\n          .map((track: any, index: number) =\u003e ({\n            id: `sub-${index}`,\n            language: track.label || \"Unknown\",\n            url: track.file,\n            isDefault: !!track.default,\n          }));\n    \n        return {\n            server: serverName,\n            headers: {\n              \"Referer\": \"https://megacloud.club/\",\n              \"Origin\": \"https://megacloud.club\",\n              \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n            },\n            videoSources: [{\n                url: streamSource.file,\n                type: streamSource.type,\n                quality: \"auto\",\n                subtitles\n            }]\n        };\n      }\n      \n    else if (_server === \"HD-4\") {\n      // Fetch Iframe\n      const iframe = await fetch(\n        `https://megaplay.buzz/stream/s-2/${id}/${subOrDub}`,\n          {\n              headers: {\n                  Referer: \"https://megaplay.buzz/api\",\n              },\n          }\n      );\n      if (!iframe.ok) throw new Error(\"Episode is not available\");\n\n      // Parse dataId\n      const iframeBody = await iframe.text();\n      const dataIdMatch = iframeBody.match(/\u003ctitle\u003e\\s*File\\s+(\\d+)\\s*-\\s*MegaPlay/i);\n      if (!dataIdMatch) throw new Error(\"data-id not found\");\n      const dataId = dataIdMatch[1];\n      \n      // Fetch HLS stream\n      const fetchData = await fetch(`https://megaplay.buzz/stream/getSources?id=${dataId}\u0026id=${dataId}`, {\n          headers: {\n              \"X-Requested-With\": \"XMLHttpRequest\",\n          }\n      }).then(res =\u003e res.json());\n    \n      // Map subtitles\n      const subtitles =\n        (fetchData.tracks || [])\n          .filter((t: any) =\u003e t.kind === \"captions\")\n          .map((track: any, index: number) =\u003e ({\n            id: `sub-${index}`,\n            language: track.label || \"Unknown\",\n            url: track.file,\n            isDefault: !!track.default,\n          }));\n\n      return {\n            server: serverName,\n            headers: {\n              'Accept': '*/*',\n              'Accept-Language': 'en-US,en;q=0.5',\n              \"Referer\": `https://megaplay.buzz/`,\n              \"Origin\": \"https://megaplay.buzz\",\n              'Sec-Fetch-Dest': 'empty',\n              'Sec-Fetch-Mode': 'cors',\n              'Sec-Fetch-Site': 'cross-site',\n              'Te': 'trailers',\n              \"User-Agent\":\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n            },\n            videoSources: [{\n                url: fetchData.sources?.file,\n                type: \"m3u8\",\n                quality: \"auto\",\n                subtitles\n            }]\n        };\n    }\n  }\n}"
}
