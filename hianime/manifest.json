{
  "id":"hianime",
  "name":"HiAnime",
  "version":"1.0.4",
  "manifestURI":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/manifest.json",
  "language":"typescript",
  "type":"onlinestream-provider",
  "description":"HiAnime is an online stream provider for both sub and dub with soft subs.",
  "author":"Thekingcrusher",
  "icon":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/hianime/logo.png",
  "lang":"en",
  "payload": "/// \u003creference path=\"./online-streaming-provider.d.ts\" /\u003e\n\nclass Provider {\n    baseUrl = \"https://hianime.to\"\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"HD-1\", \"HD-2\", \"HD-3\", \"HD-4\"],\n            supportsDub: true\n        }\n    }\n\n    async search(query: SearchOptions): Promise\u003cSearchResult[]\u003e {\n      const normalize = (str: any) =\u003e\n        safeString(str).toLowerCase().replace(/[^a-z0-9]+/g, \"\"); // strip spaces \u0026 special chars\n    \n      const start = query.media.startDate;\n      const targetNorm = normalize(normalizeSeasonParts(query.media.romajiTitle));\n      const targetNormEN = query.media.englishTitle ? normalize(normalizeSeasonParts(query.media.englishTitle)) : targetNorm;\n    \n      const fetchMatches = async (url: string) =\u003e {\n        const html = await fetch(url).then(res =\u003e res.text());\n        // Match the main link\n        const regex = /\u003ca href=\"\\/watch\\/([^\"]+)\"[^\u003e]+title=\"([^\"]+)\"[^\u003e]+data-id=\"(\\d+)\"/g;\n        return [...html.matchAll(regex)].map(m =\u003e {\n          const id = m[3];\n          const pageUrl = m[1];\n          const title = m[2];\n          // Find corresponding data-jname\n          const jnameRegex = new RegExp(\n            `\u003ch3 class=\"film-name\"\u003e[\\\\s\\\\S]*?\u003ca[^\u003e]+href=\"\\\\/${pageUrl}[^\"]*\"[^\u003e]+data-jname=\"([^\"]+)\"`,\n            \"i\"\n          );\n          const jnameMatch = html.match(jnameRegex);\n          const jname = jnameMatch ? jnameMatch[1] : null;\n          return {\n            id,\n            pageUrl,\n            title,\n            normTitleJP: normalize(normalizeSeasonParts(jname)),\n            normTitle: normalize(normalizeSeasonParts(title)),\n          };\n        });\n      };\n    \n      // Base search\n      let url = `${this.baseUrl}/search?keyword=${encodeURIComponent(query.query)}\u0026sy=${start.year}\u0026sm=${start.month}\u0026sort=default`;\n      let matches = await fetchMatches(url);\n    \n      if (matches.length === 0) return [];\n    \n      // Levenshtein helper\n      const levenshtein = (a: string, b: string) =\u003e {\n        const dp: number[][] = Array.from({ length: a.length + 1 }, () =\u003e Array(b.length + 1).fill(0));\n        for (let i = 0; i \u003c= a.length; i++) dp[i][0] = i;\n        for (let j = 0; j \u003c= b.length; j++) dp[0][j] = j;\n        for (let i = 1; i \u003c= a.length; i++) {\n          for (let j = 1; j \u003c= b.length; j++) {\n            dp[i][j] =\n              a[i - 1] === b[j - 1]\n                ? dp[i - 1][j - 1]\n                : 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n          }\n        }\n        return dp[a.length][b.length];\n      };\n    \n      // Pick best match: exact \u003e partial \u003e Levenshtein\n      let best = matches.find(m =\u003e m.normTitleJP === targetNorm);\n      let fallbackNorm = targetNorm;\n    \n      if (!best) {\n        best = matches.find(m =\u003e m.normTitle === targetNormEN);\n        fallbackNorm = targetNormEN;\n      }\n    \n      // Partial match: one string contains the other\n      if (!best) {\n        best = matches.find(\n          m =\u003e fallbackNorm.includes(m.normTitle) || m.normTitle.includes(fallbackNorm)\n        );\n      }\n    \n      // Levenshtein fallback\n      if (!best) {\n        matches.sort(\n          (a, b) =\u003e levenshtein(a.normTitle, fallbackNorm) - levenshtein(b.normTitle, fallbackNorm)\n        );\n        best = matches[0];\n      }\n    \n      return [\n        {\n          id: `${best.id}/${query.dub ? \"dub\" : \"sub\"}`,\n          title: best.title,\n          url: `${this.baseUrl}/${best.pageUrl}`,\n          subOrDub: query.dub ? \"dub\" : \"sub\",\n        },\n      ];\n    }\n\n    async findEpisodes(animeId: string): Promise\u003cEpisodeDetails[]\u003e {\n      const [id, subOrDub] = animeId.split(\"/\");\n      const res = await fetch(`${this.baseUrl}/ajax/v2/episode/list/${id}`, {\n          headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n      });\n      const json = await res.json();\n      const html = json.html;\n  \n      const episodes = [];\n      const regex = /\u003ca[^\u003e]*class=\"[^\"]*\\bep-item\\b[^\"]*\"[^\u003e]*data-number=\"(\\d+)\"[^\u003e]*data-id=\"(\\d+)\"[^\u003e]*href=\"([^\"]+)\"[\\s\\S]*?\u003cdiv class=\"ep-name[^\"]*\"[^\u003e]*title=\"([^\"]+)\"/g;\n  \n      let match;\n      while ((match = regex.exec(html)) !== null) {\n          episodes.push({\n              id: `${match[2]}/${subOrDub}`, // episode's internal ID\n              number: parseInt(match[1], 10),\n              url: this.baseUrl+match[3],\n              title: match[4],\n          });\n      }\n  \n      return episodes;\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n      const [id, subOrDub] = episode.id.split(\"/\");\n      let serverName = _server !== \"default\" ? _server : \"HD-1\";\n\n      if (_server === \"HD-1\" || _server === \"HD-2\" || _server === \"HD-3\") {\n        // Fetch server list\n        const serverJson = await fetch(`${this.baseUrl}/ajax/v2/episode/servers?episodeId=${id}`, {\n            headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n        }).then(res =\u003e res.json());\n        \n        const serverHtml = serverJson.html;\n    \n        // Regex to match the right block (sub or dub) and find the server by name\n        const regex = new RegExp(\n            `\u003cdiv[^\u003e]*class=\"item server-item\"[^\u003e]*data-type=\"${subOrDub}\"[^\u003e]*data-id=\"(\\\\d+)\"[^\u003e]*\u003e\\\\s*\u003ca[^\u003e]*\u003e\\\\s*${serverName}\\\\s*\u003c/a\u003e`,\n            \"i\"\n        );\n    \n        const match = regex.exec(serverHtml);\n        if (!match) throw new Error(`Server \"${serverName}\" (${subOrDub}) not found`);\n    \n        const serverId = match[1];\n    \n        // Fetch source embed\n        const sourcesJson = await fetch(`${this.baseUrl}/ajax/v2/episode/sources?id=${serverId}`, {\n            headers: { \"X-Requested-With\": \"XMLHttpRequest\" }\n        }).then(res =\u003e res.json());\n\n        let decryptData = null;\n\n        try {\n          decryptData = await extractMegaCloud(sourcesJson.link);\n        } catch (err) {\n          console.warn(\"Primary decrypter failed:\", err);\n        }\n        \n        // Fallback to ShadeOfChaos if primary fails or no valid data\n        if (!decryptData) {\n          console.warn(\"Primary decrypter failed â€” trying ShadeOfChaos fallback...\");\n          const fallbackRes = await fetch(\n            `https://ac-api.ofchaos.com/api/anime/embed/convert/v2?embedUrl=${encodeURIComponent(sourcesJson.link)}`\n          );\n          decryptData = await fallbackRes.json();\n        }\n    \n        // Get HLS or MP4 stream\n        const streamSource =\n          decryptData.sources.find((s: any) =\u003e s.type === \"hls\") ||\n          decryptData.sources.find((s: any) =\u003e s.type === \"mp4\");\n      \n        if (!streamSource?.file) throw new Error(\"No valid stream file found\");\n      \n        // Map subtitles\n        const subtitles =\n          (decryptData.tracks || [])\n            .filter((t: any) =\u003e t.kind === \"captions\")\n            .map((track: any, index: number) =\u003e ({\n              id: `sub-${index}`,\n              language: track.label || \"Unknown\",\n              url: track.file,\n              isDefault: !!track.default,\n            }));\n      \n          return {\n              server: serverName,\n              headers: {\n                \"Referer\": \"https://megacloud.club/\",\n                \"Origin\": \"https://megacloud.club\",\n                \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n              },\n              videoSources: [{\n                  url: streamSource.file,\n                  type: streamSource.type === \"hls\" ? \"m3u8\" : \"mp4\",\n                  quality: \"auto\",\n                  subtitles\n              }]\n          };\n        }\n      \n    else if (_server === \"HD-4\") {\n      // Fetch Iframe\n      const iframe = await fetch(\n        `https://megaplay.buzz/stream/s-2/${id}/${subOrDub}`,\n          {\n              headers: {\n                  Referer: \"https://megaplay.buzz/api\",\n              },\n          }\n      );\n      if (!iframe.ok) throw new Error(\"Episode is not available\");\n\n      // Parse dataId\n      const iframeBody = await iframe.text();\n      const dataIdMatch = iframeBody.match(/\u003ctitle\u003e\\s*File\\s+(\\d+)\\s*-\\s*MegaPlay/i);\n      if (!dataIdMatch) throw new Error(\"data-id not found\");\n      const dataId = dataIdMatch[1];\n      \n      // Fetch HLS stream\n      const fetchData = await fetch(`https://megaplay.buzz/stream/getSources?id=${dataId}\u0026id=${dataId}`, {\n          headers: {\n              \"X-Requested-With\": \"XMLHttpRequest\",\n          }\n      }).then(res =\u003e res.json());\n    \n      // Map subtitles\n      const subtitles =\n        (fetchData.tracks || [])\n          .filter((t: any) =\u003e t.kind === \"captions\")\n          .map((track: any, index: number) =\u003e ({\n            id: `sub-${index}`,\n            language: track.label || \"Unknown\",\n            url: track.file,\n            isDefault: !!track.default,\n          }));\n\n      return {\n            server: serverName,\n            headers: {\n              'Accept': '*/*',\n              'Accept-Language': 'en-US,en;q=0.5',\n              \"Referer\": `https://megaplay.buzz/`,\n              \"Origin\": \"https://megaplay.buzz\",\n              'Sec-Fetch-Dest': 'empty',\n              'Sec-Fetch-Mode': 'cors',\n              'Sec-Fetch-Site': 'cross-site',\n              'Te': 'trailers',\n              \"User-Agent\":\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n            },\n            videoSources: [{\n                url: fetchData.sources?.file,\n                type: \"m3u8\",\n                quality: \"auto\",\n                subtitles\n            }]\n        };\n    }\n  }\n}\n\nconst safeString = (str: any) =\u003e (typeof str === \"string\" ? str : \"\");\n\nfunction normalizeSeasonParts(title) {\n  const s = safeString(title);\n  return s\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"\")                 // remove non-alphanumerics\n    .replace(/\\d+(st|nd|rd|th)/g, (m) =\u003e m.replace(/st|nd|rd|th/, \"\")) // remove ordinal suffix\n    .replace(/season|cour|part/g, \"\");              // strip \"season\"/\"cour\"/\"part\"\n}\n\nasync function extractMegaCloud(embedUrl: string) {\n  const url = new URL(embedUrl);\n  const baseDomain = `${url.protocol}//${url.host}/`;\n\n  const headers = {\n    \"Accept\": \"*/*\",\n    \"X-Requested-With\": \"XMLHttpRequest\",\n    \"Referer\": baseDomain,\n    \"User-Agent\":\n      \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36\",\n  };\n\n  // Fetch embed page\n  const html = await fetch(embedUrl, { headers }).then((r) =\u003e r.text());\n\n  // Extract file ID\n  const fileIdMatch = html.match(/\u003ctitle\u003e\\s*File\\s+#([a-zA-Z0-9]+)\\s*-/i);\n  if (!fileIdMatch) throw new Error(\"file_id not found in embed page\");\n  const fileId = fileIdMatch[1];\n\n  // Extract nonce\n  let nonce: string | null = null;\n  const match48 = html.match(/\\b[a-zA-Z0-9]{48}\\b/);\n  if (match48) nonce = match48[0];\n  else {\n    const match3x16 = [...html.matchAll(/[\"']([A-Za-z0-9]{16})[\"']/g)];\n    if (match3x16.length \u003e= 3) {\n      nonce = match3x16[0][1] + match3x16[1][1] + match3x16[2][1];\n    }\n  }\n  if (!nonce) throw new Error(\"nonce not found\");\n\n  // Fetch sources\n  const sourcesJson = await fetch(\n    `${baseDomain}embed-2/v3/e-1/getSources?id=${fileId}\u0026_k=${nonce}`,\n    { headers }\n  ).then((r) =\u003e r.json());\n\n  return {\n    sources: sourcesJson.sources,\n    tracks: sourcesJson.tracks || [],\n    intro: sourcesJson.intro || null,\n    outro: sourcesJson.outro || null,\n    server: sourcesJson.server || null,\n  };\n}"
}
