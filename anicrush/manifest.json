{
  "id":"anicrush",
  "name":"Anicrush",
  "version":"1.0.5",
  "manifestURI":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/anicrush/manifest.json",
  "language":"typescript",
  "type":"onlinestream-provider",
  "description":"Anicrush is an online stream provider for both sub and dub with soft subs.",
  "author":"Thekingcrusher",
  "icon":"https://raw.githubusercontent.com/Thekingcrusher/online-stream-providers/refs/heads/main/anicrush/logo.png",
  "lang":"en",
  "payload": "/// \u003creference path=\"./online-streaming-provider.d.ts\" /\u003e\n\nclass Provider {\n  private baseUrl = \"https://anicrush.to\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Southcloud-1\", \"Southcloud-2\", \"Southcloud-3\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise\u003cSearchResult[]\u003e {\n    const normalize = (str: any) =\u003e\n      safeString(str).toLowerCase().replace(/[^a-z0-9]+/g, \"\"); // strip spaces \u0026 special chars\n\n    const start = query.media.startDate;\n    const targetNorm = normalize(normalizeSeasonParts(query.media.romajiTitle));\n    const targetNormEN = query.media.englishTitle ? normalize(normalizeSeasonParts(query.media.englishTitle)) : targetNorm;\n    \n    const fetchMatches = async (url: string) =\u003e {\n      const html = await fetch(url, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"Accept\": \"application/json\",\n          \"Referer\": this.baseUrl + \"/\",\n          \"Origin\": this.baseUrl,\n          \"X-Site\": \"anicrush\",\n        },\n      }).then(res =\u003e res.json());\n      return html.result?.movies.map((movie: any) =\u003e ({\n        id: movie.id,\n        pageUrl: movie.slug,\n        title: movie.name_english || movie.name,\n        normTitleJP: normalize(normalizeSeasonParts(movie.name)),\n        normTitle: normalize(normalizeSeasonParts(movie.name_english)),\n        dub: movie.has_dub,\n        startDate: normalizeDate(movie.aired_from),\n      }));\n    };\n    \n    // Base search\n    let url = `https://api.anicrush.to/shared/v2/movie/list?keyword=${encodeURIComponent(query.query)}\u0026limit=24\u0026page=1`;\n    let matches = await fetchMatches(url);\n    if (!matches || matches.length === 0) return [];\n\n    // If dub requested, filter only dub-capable matches\n    if (query.dub) {\n      matches = matches.filter(m =\u003e m.dub);\n      if (matches.length === 0) return []; // no dub available\n    }\n    \n    // Levenshtein helper\n    const levenshtein = (a: string, b: string) =\u003e {\n      const dp: number[][] = Array.from({ length: a.length + 1 }, () =\u003e Array(b.length + 1).fill(0));\n      for (let i = 0; i \u003c= a.length; i++) dp[i][0] = i;\n      for (let j = 0; j \u003c= b.length; j++) dp[0][j] = j;\n      for (let i = 1; i \u003c= a.length; i++) {\n        for (let j = 1; j \u003c= b.length; j++) {\n          dp[i][j] =\n            a[i - 1] === b[j - 1]\n              ? dp[i - 1][j - 1]\n              : 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n        }\n      }\n      return dp[a.length][b.length];\n    };\n    \n    // Pick best match: exact \u003e partial \u003e Levenshtein\n    let best = matches.find(m =\u003e\n      m.normTitleJP === targetNorm \u0026\u0026\n      m.startDate?.year === start.year \u0026\u0026\n      m.startDate?.month === start.month\n    );\n    \n    let fallbackNorm = targetNorm;\n    \n    if (!best) {\n      best = matches.find(m =\u003e\n        m.normTitle === targetNormEN \u0026\u0026\n        m.startDate?.year === start.year \u0026\u0026\n        m.startDate?.month === start.month\n      );\n      fallbackNorm = targetNormEN;\n    }\n    \n    // Partial match: one string contains the other\n    if (!best) {\n      best = matches.find(m =\u003e\n        (fallbackNorm.includes(m.normTitle) || m.normTitle.includes(fallbackNorm)) \u0026\u0026\n        (m.startDate?.year === start.year \u0026\u0026 m.startDate?.month === start.month)\n      );\n    }\n    \n    // Levenshtein fallback\n    if (!best) {\n      matches.sort(\n        (a, b) =\u003e levenshtein(a.normTitle, fallbackNorm) - levenshtein(b.normTitle, fallbackNorm)\n      );\n      best = matches[0];\n    }\n    \n    return [\n      {\n        id: `${best.id}/${query.dub ? \"dub\" : \"sub\"}`,\n        title: best.title,\n        url: `${this.baseUrl}/detail/${best.pageUrl}.${best.id}`,\n        subOrDub: query.dub ? \"dub\" : \"sub\",\n      },\n    ];\n  }\n\n  async findEpisodes(Id: string): Promise\u003cEpisode[]\u003e {\n    const [id, subOrDub] = Id.split(\"/\");\n\n    const epRes = await fetch(\n      `https://api.anicrush.to/shared/v2/episode/list?_movieId=${id}`,\n      {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"Accept\": \"application/json\",\n          \"Referer\": this.baseUrl + \"/\",\n          \"Origin\": this.baseUrl,\n          \"X-Site\": \"anicrush\",\n        },\n      }\n    );\n\n    const epJson = await epRes.json();\n    const episodeGroups = epJson?.result ?? {};\n    const episodes: Episode[] = [];\n\n    for (const group of Object.values(episodeGroups)) {\n      if (!Array.isArray(group)) continue;\n\n      for (const ep of group) {\n        episodes.push({\n          id: `${id}/${subOrDub}`,\n          number: ep.number,\n          title: ep.name_english,\n          url: \"\",\n        });\n      }\n    }\n\n    return episodes;\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n    const [id, subOrDub] = episode.id.split(\"/\");\n  \n    const serverMap: Record\u003cstring, number\u003e = {\n      \"Southcloud-1\": 4,\n      \"Southcloud-2\": 1,\n      \"Southcloud-3\": 6,\n    };\n  \n    const sv = serverMap[_server] ?? 4;\n  \n    const encryptedLinkUrl = `https://api.anicrush.to/shared/v2/episode/sources?_movieId=${id}\u0026ep=${episode.number}\u0026sv=${sv}\u0026sc=${subOrDub}`;\n  \n    try {\n      // Fetch encrypted link\n      const res = await fetch(encryptedLinkUrl, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"Accept\": \"application/json\",\n          \"Referer\": this.baseUrl + \"/\",\n          \"Origin\": this.baseUrl,\n          \"X-Site\": \"anicrush\",\n        },\n      });\n  \n      const json = await res.json();\n      const encryptedIframe = json?.result?.link;\n      if (!encryptedIframe) throw new Error(\"Missing encrypted iframe link\");\n  \n      // Try primary decrypter\n      let decryptData = null;\n      try {\n        decryptData = await extractMegaCloud(encryptedIframe);\n      } catch (err) {\n        console.warn(\"Primary decrypter failed:\", err);\n      }\n  \n      // Fallback to ShadeOfChaos if primary fails or no valid data\n      if (!decryptData) {\n        console.warn(\"Primary decrypter failed â€” trying ShadeOfChaos fallback...\");\n        const fallbackRes = await fetch(\n          `https://ac-api.ofchaos.com/api/anime/embed/convert/v2?embedUrl=${encodeURIComponent(encryptedIframe)}`\n        );\n        decryptData = await fallbackRes.json();\n      }\n  \n      // Still nothing? Fail\n      if (!decryptData) throw new Error(\"No video sources from any decrypter\");\n  \n      // Get HLS or MP4 stream\n      const streamSource =\n        decryptData.sources.find((s: any) =\u003e s.type === \"hls\") ||\n        decryptData.sources.find((s: any) =\u003e s.type === \"mp4\");\n  \n      if (!streamSource?.file) throw new Error(\"No valid stream file found\");\n  \n      // Map subtitles\n      const subtitles =\n        (decryptData.tracks || [])\n          .filter((t: any) =\u003e t.kind === \"captions\")\n          .map((track: any, index: number) =\u003e ({\n            id: `sub-${index}`,\n            language: track.label || \"Unknown\",\n            url: track.file,\n            isDefault: !!track.default,\n          }));\n  \n      // Return playable server object\n      return {\n        server: _server,\n        headers: {\n          \"Referer\": \"https://megacloud.club/\",\n          \"Origin\": \"https://megacloud.club\",\n          \"User-Agent\":\n            \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0\",\n        },\n        videoSources: [\n          {\n            url: streamSource.file,\n            type: streamSource.type,\n            quality: \"auto\",\n            subtitles,\n          },\n        ],\n      };\n    } catch (err) {\n      console.warn(`Failed on ${_server}`, err);\n      throw new Error(`No stream found for ${_server}`);\n    }\n  }\n}\n\nconst safeString = (str: any) =\u003e (typeof str === \"string\" ? str : \"\");\n\nfunction normalizeDate(dateStr) {\n    if (!dateStr) return null;\n\n    const months = {\n        Jan: \"1\", Feb: \"2\", Mar: \"3\", Apr: \"4\",\n        May: \"5\", Jun: \"6\", Jul: \"7\", Aug: \"8\",\n        Sep: \"9\", Oct: \"10\", Nov: \"11\", Dec: \"12\"\n    };\n\n    const match = dateStr.match(/([A-Za-z]+)\\s+(\\d{1,2}),\\s*(\\d{4})/);\n    if (!match) return null;\n\n    const month = months[match[1]];\n    const day = match[2].padStart(2, \"0\");\n    const year = match[3];\n\n    return {\n      year: parseInt(year),\n      month: parseInt(month),\n    };\n}\n\nfunction normalizeSeasonParts(title) {\n  const s = safeString(title);\n  return s\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"\")                 // remove non-alphanumerics\n    .replace(/\\d+(st|nd|rd|th)/g, (m) =\u003e m.replace(/st|nd|rd|th/, \"\")) // remove ordinal suffix\n    .replace(/season|cour|part/g, \"\");              // strip \"season\"/\"cour\"/\"part\"\n}\n\nasync function extractMegaCloud(embedUrl: string) {\n  const url = new URL(embedUrl);\n  const baseDomain = `${url.protocol}//${url.host}/`;\n\n  const headers = {\n    \"Accept\": \"*/*\",\n    \"X-Requested-With\": \"XMLHttpRequest\",\n    \"Referer\": baseDomain,\n    \"User-Agent\":\n      \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36\",\n  };\n\n  // Fetch embed page\n  const html = await fetch(embedUrl, { headers }).then((r) =\u003e r.text());\n\n  // Extract file ID\n  const fileIdMatch = html.match(/\u003ctitle\u003e\\s*File\\s+#([a-zA-Z0-9]+)\\s*-/i);\n  if (!fileIdMatch) throw new Error(\"file_id not found in embed page\");\n  const fileId = fileIdMatch[1];\n\n  // Extract nonce\n  let nonce: string | null = null;\n  const match48 = html.match(/\\b[a-zA-Z0-9]{48}\\b/);\n  if (match48) nonce = match48[0];\n  else {\n    const match3x16 = [...html.matchAll(/[\"']([A-Za-z0-9]{16})[\"']/g)];\n    if (match3x16.length \u003e= 3) {\n      nonce = match3x16[0][1] + match3x16[1][1] + match3x16[2][1];\n    }\n  }\n  if (!nonce) throw new Error(\"nonce not found\");\n\n  // Fetch sources\n  const sourcesJson = await fetch(\n    `${baseDomain}embed-2/v3/e-1/getSources?id=${fileId}\u0026_k=${nonce}`,\n    { headers }\n  ).then((r) =\u003e r.json());\n\n  return {\n    sources: sourcesJson.sources,\n    tracks: sourcesJson.tracks || [],\n    intro: sourcesJson.intro || null,\n    outro: sourcesJson.outro || null,\n    server: sourcesJson.server || null,\n  };\n}"
}
